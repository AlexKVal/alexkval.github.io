[{"categories":["Ruby","Ruby on Rails","Refactoring"],"content":"\nLong methods vs simple ones. What‚Äôs the problem?\nLong methods‚Äô issues:\nusually does too much and ‚Äúknows‚Äù too much as a consequence, it breaks the Single Responsibility Principle it is harder to grasp what it does when you read it more changes needed to add or amend functionality you have to write pretty complex tests and you need a lot of them to cover all of the possible permutations Benefits of simple methods:\ndoes one thing as a consequence, it follows the Single Responsibility Principle it is easy to grasp what it does from the first glance a small number of changes, usually by adding another simple method short and simple tests that covers all the cases Let‚Äôs take a look at a (totally made-up) example:\nclass Item \u003c ApplicationRecord DEFAULT_AGGR_LAT = 0.5 DEFAULT_AGGR_LONG = 0.5 def synchronize_with(incoming_data_item) # update simple attributes self.attr_short_name = incoming_data_item.attr_short_name self.attr_fancy_name = incoming_data_item.attr_fancy_name self.attr_just_usual_name = incoming_data_item.attr_just_usual_name # update complex attributes self.coordinates = [incoming_data_item.lat, incoming_data_item.long] self.complex_attr1 = {a: incoming_data_item.simple1, b: incoming_data_item.simple2, c: incoming_data_item.simple3} # calculate aggregated values aggregated_latitude = if incoming_data_item.lat \u003e 123 (incoming_data_item.lat + 0.123) / 3 elsif incoming_data_item.lat \u003c 0.23 (incoming_data_item.lat + 24) * 1.5 else DEFAULT_AGGR_LAT end aggregated_longitude = if incoming_data_item.long \u003e 4 (incoming_data_item.long - 0.25) * 2.3 elsif incoming_data_item.long \u003c -3 incoming_data_item.long.abs / 1.1 else DEFAULT_AGGR_LONG end # update aggregated attributes self.aggregated_coordinates = [aggregated_latitude, aggregated_longitude] self.coordinates_text = \"lat: #{aggregated_latitude}, long: #{aggregated_longitude}\" save! end end We are lucky if the author has added those explaining comments. At least we have something to begin our understanding with.\nNow, try to imagine how many tests you would need to cover all the possible edge cases, nil values, etc., and their permutations.\nMost likely this method would have only one - success path - test. It would be long and require explaining comments in it.\nMaybe there will be one or two additional tests that were added later, when some bug has been caught in the production.\nThose are usually called ‚Äúanti-regression‚Äù tests.\nSo how we should fix this long method?\nI would use the explaining comments as hints for the new methods. Looking at our example, the resulting method should look something like this:\nclass Item \u003c ApplicationRecord # ... def synchronize_with(incoming_data_item) @incoming_data_item = incoming_data_item # update_simple_attributes update_complex_attributes calculate_aggregated_values update_aggregated_attributes # save! end # ... end As a consequence:\nyou don‚Äôt need the explaining comments the code itself ‚Äúreads‚Äù as documentation now you can write simple tests for each of those simpler methods the test for the synchronize_with method now is dead simple ‚ÄúBut how do you hand over the intermediate state between the methods?‚Äù you would ask.\nI would use either instance variables for that, or better yet, the attribute accessors for them.\nThere are many good articles out there explaining why you should prefer attribute accessors. I‚Äôll skip this part here instead of just instance variables in most cases.\nSo the first one is the incoming incoming_data_item data. We only read its value, so the attr_reader is enough.\nclass Item \u003c ApplicationRecord attr_reader :incoming_data_item # ... end This way, the first method could be just a copy-past of the existing code:\n# before # update simple attributes self.attr_short_name = incoming_data_item.attr_short_name self.attr_fancy_name = incoming_data_item.attr_fancy_name self.attr_just_usual_name = incoming_data_item.attr_just_usual_name # after def update_simple_attributes self.attr_short_name = incoming_data_item.attr_short_name self.attr_fancy_name = incoming_data_item.attr_fancy_name self.attr_just_usual_name = incoming_data_item.attr_just_usual_name end As you can imagine, the testing of the update_simple_attributes method is now dead simple and it is really easy to cover all the nil and other edge cases.\nOk, what about the update_complex_attributes method? For starters, we can do the same copy-paste and that already would be a gain.\n# before # update complex attributes self.coordinates = [incoming_data_item.lat, incoming_data_item.long] self.complex_attr1 = {a: incoming_data_item.simple1, b: incoming_data_item.simple2, c: incoming_data_item.simple3} # after def update_complex_attributes self.coordinates = [incoming_data_item.lat, incoming_data_item.long] self.complex_attr1 = {a: incoming_data_item.simple1, b: incoming_data_item.simple2, c: incoming_data_item.simple3} end But now looking at the resulting method, it is apparent that the new method ‚Äúknows‚Äù too much about the incoming_data_item attributes.\nWe definitely have the ‚ÄúTell, Don‚Äôt Ask‚Äù code smell here.\nIdeally, we want something like this instead:\ndef update_complex_attributes self.coordinates = incoming_data_item.coordinates self.complex_attr1 = incoming_data_item.complex_attr1 end This way the tests for the update_complex_attributes also become dead simple now.\nAnd here are the new methods that we would add to the incoming_data_item‚Äôs class:\nclass IncomingDataItem # ... # incoming_data_item -\u003e self def coordinates [self.lat, self.long] end def complex_attr1 {a: self.simple1, b: self.simple2, c: self.simple3} end end Obviously, you don‚Äôt need to use self here. I‚Äôm just showing an intermediate result of the entire method‚Äôs extraction.\nclass IncomingDataItem # ... def coordinates [lat, long] end def complex_attr1 {a: simple1, b: simple2, c: simple3} end end Here is a word of caution though.\nWhen we ‚Äúmove‚Äù this way functionality into the ‚Äúchildren‚Äù classes, eventually, they become ‚ÄúGod Objects‚Äù that do too much.\nThis is the opposite side of the ‚ÄúTell, Don‚Äôt Ask‚Äù principle.\nThere are different methods to address this issue, but it is a topic for another article. Now let‚Äôs get back to the rest of the extracted methods.\nHere is the original calculate aggregated values code:\n# calculate aggregated values aggregated_latitude = if incoming_data_item.lat \u003e 123 (incoming_data_item.lat + 0.123) / 3 elsif incoming_data_item.lat \u003c 0.23 (incoming_data_item.lat + 24) * 1.5 else DEFAULT_AGGR_LAT end aggregated_longitude = if incoming_data_item.long \u003e 4 (incoming_data_item.long - 0.25) * 2.3 elsif incoming_data_item.long \u003c -3 incoming_data_item.long.abs / 1.1 else DEFAULT_AGGR_LONG end If we move the existing code into the new method, we would need to write tests that cover both ‚Äúbranches‚Äù of the new method. They would be long and hard to read.\nInstead, we can either extract two sub-methods smth like this:\ndef calculate_aggregated_values calculate_aggregated_latitude calculate_aggregated_longitude end def calculate_aggregated_latitude # ... end def calculate_aggregated_longitude # ... end That would already be a good win.\nOr we can get rid of the calculate_aggregated_values method at all if we think that the resulting code‚Äôs readability remains to be good.\nclass Item \u003c ApplicationRecord # ... def synchronize_with(incoming_data_item) @incoming_data_item = incoming_data_item # update_simple_attributes update_complex_attributes # here is the changed part: instead of the `calculate_aggregated_values`, we have two methods calculate_aggregated_latitude calculate_aggregated_longitude update_aggregated_attributes # save! end # ... def calculate_aggregated_latitude # ... end def calculate_aggregated_longitude # ... end end And here are the new methods themselves:\nDEFAULT_AGGR_LAT = 0.5 attr_reader :aggregated_latitude def calculate_aggregated_latitude @aggregated_latitude = if incoming_data_item.lat \u003e 123 (incoming_data_item.lat + 0.123) / 3 elsif incoming_data_item.lat \u003c 0.23 (incoming_data_item.lat + 24) * 1.5 else DEFAULT_AGGR_LAT end end DEFAULT_AGGR_LONG = 0.5 attr_reader :aggregated_longitude def calculate_aggregated_longitude @aggregated_longitude = if incoming_data_item.long \u003e 4 (incoming_data_item.long - 0.25) * 2.3 elsif incoming_data_item.long \u003c -3 incoming_data_item.long.abs / 1.1 else DEFAULT_AGGR_LONG end end Notice that we need two new attr readers for the intermediate state handover.\nAlso, it is mostly a matter of taste and the team‚Äôs preferences, we can move the constants next to the methods where they are used.\nAgain, now after we‚Äôve moved the code into the new separate methods, it becomes apparent, that the methods ‚Äúknow‚Äù too much about the incoming_data_item and also they ‚Äúask‚Äù it many times, hence we have the ‚ÄúTell, Don‚Äôt Ask‚Äù code smell.\nLet‚Äôs fix it by moving the functionality to the incoming_data_item‚Äôs class.\nHere is the new code for the IncomingDataItem class. Notice that we also moved the constants.\nclass IncomingDataItem # ... DEFAULT_AGGR_LAT = 0.5 def aggregated_latitude if lat \u003e 123 (lat + 0.123) / 3 elsif lat \u003c 0.23 (lat + 24) * 1.5 else DEFAULT_AGGR_LAT end end DEFAULT_AGGR_LONG = 0.5 def aggregated_longitude if long \u003e 4 (long - 0.25) * 2.3 elsif long \u003c -3 long.abs / 1.1 else DEFAULT_AGGR_LONG end end # ... end Now we don‚Äôt need those two new attr readers in the parent‚Äôs class. And the resulting synchronize_with method is also simpler now:\nclass Item \u003c ApplicationRecord def synchronize_with(incoming_data_item) @incoming_data_item = incoming_data_item # update_simple_attributes update_complex_attributes # no need for a separate \"calculate aggregated values\" stage/method update_aggregated_attributes # save! end end Ok. Now let‚Äôs tackle the last update aggregated attributes part.\nHere is the initial code for it:\n# update aggregated attributes self.aggregated_coordinates = [aggregated_latitude, aggregated_longitude] self.coordinates_text = \"lat: #{aggregated_latitude}, long: #{aggregated_longitude}\" Here we also can just copy-paste the code into a new method, but instead of the aggregated_latitude/_longitude accessors, we use the new methods of the incoming_data_item instance like this:\ndef update_aggregated_attributes self.aggregated_coordinates = [incoming_data_item.aggregated_latitude, incoming_data_item.aggregated_longitude] self.coordinates_text = \"lat: #{incoming_data_item.aggregated_latitude}, long: #{incoming_data_item.aggregated_longitude}\" end And again, let‚Äôs address the ‚ÄúTell, Don‚Äôt Ask‚Äù. Here is the new -dead simple- code for the IncomingDataItem class:\nclass IncomingDataItem # ... def aggregated_coordinates [aggregated_latitude, aggregated_longitude] end def coordinates_text \"lat: #{aggregated_latitude}, long: #{aggregated_longitude}\" end # ... end As you can imagine, the tests for these new methods also would be pretty short and dead simple.\nAnd here is the usage of these new methods:\ndef update_aggregated_attributes self.aggregated_coordinates = incoming_data_item.aggregated_coordinates self.coordinates_text = incoming_data_item.coordinates_text end Now we have three pretty simple and pretty similar-looking methods in the parent class:\ndef update_simple_attributes self.attr_short_name = incoming_data_item.attr_short_name self.attr_fancy_name = incoming_data_item.attr_fancy_name self.attr_just_usual_name = incoming_data_item.attr_just_usual_name end def update_complex_attributes self.coordinates = incoming_data_item.coordinates self.complex_attr1 = incoming_data_item.complex_attr1 end def update_aggregated_attributes self.aggregated_coordinates = incoming_data_item.aggregated_coordinates self.coordinates_text = incoming_data_item.coordinates_text end We can combine them into one:\ndef update_attributes # \u003c= new method self.attr_short_name = incoming_data_item.attr_short_name self.attr_fancy_name = incoming_data_item.attr_fancy_name self.attr_just_usual_name = incoming_data_item.attr_just_usual_name self.coordinates = incoming_data_item.coordinates self.complex_attr1 = incoming_data_item.complex_attr1 self.aggregated_coordinates = incoming_data_item.aggregated_coordinates self.coordinates_text = incoming_data_item.coordinates_text end But looking at the whole picture, it is apparent that we don‚Äôt need that intermediate method. Neither do we the attr_reader :incoming_data_item.\nHere is the updated synchronize_with method:\ndef synchronize_with(incoming_data_item) self.attr_short_name = incoming_data_item.attr_short_name self.attr_fancy_name = incoming_data_item.attr_fancy_name self.attr_just_usual_name = incoming_data_item.attr_just_usual_name self.coordinates = incoming_data_item.coordinates self.complex_attr1 = incoming_data_item.complex_attr1 self.aggregated_coordinates = incoming_data_item.aggregated_coordinates self.coordinates_text = incoming_data_item.coordinates_text save! end The AR‚Äôs update! method does the same:\nupdates the attribute‚Äôs values and uses the save! under the hood So let‚Äôs use it instead:\ndef synchronize_with(incoming_data_item) update!( attr_short_name: incoming_data_item.attr_short_name, attr_fancy_name: incoming_data_item.attr_fancy_name, attr_just_usual_name: incoming_data_item.attr_just_usual_name, coordinates: incoming_data_item.coordinates, complex_attr1: incoming_data_item.complex_attr1, aggregated_coordinates: incoming_data_item.aggregated_coordinates, coordinates_text: incoming_data_item.coordinates_text, ) end Again, ‚ÄúTell, Don‚Äôt Ask‚Äù. Let‚Äôs use the attributes convention:\nclass IncomingDataItem # ... def attributes { attr_short_name: attr_short_name, attr_fancy_name: attr_fancy_name, attr_just_usual_name: attr_just_usual_name, coordinates: coordinates, complex_attr1: complex_attr1, aggregated_coordinates: aggregated_coordinates, coordinates_text: coordinates_text, } end # ... end This way the synchronize_with method becomes a simple one-liner:\ndef synchronize_with(incoming_data_item) update!(incoming_data_item.attributes) end With this one-liner, we can consider getting rid of it for good. Here is what it would look like:\n# find all the \"before\" usage item_instance.synchronize_with(incoming_data_item) # and change it to the \"after\" item_instance.update!(incoming_data_item.attributes) Personally, I would prefer to use the synchronize_with one-liner. The ‚Äúouter‚Äù tests would be more straightforward with it.\nHere is the resulting complete code for both classes to see the entire picture:\nclass Item \u003c ApplicationRecord def synchronize_with(incoming_data_item) update!(incoming_data_item.attributes) end end class IncomingDataItem def attributes { attr_short_name: attr_short_name, attr_fancy_name: attr_fancy_name, attr_just_usual_name: attr_just_usual_name, coordinates: coordinates, complex_attr1: complex_attr1, aggregated_coordinates: aggregated_coordinates, coordinates_text: coordinates_text, } end def coordinates [lat, long] end def complex_attr1 {a: simple1, b: simple2, c: simple3} end def aggregated_coordinates [aggregated_latitude, aggregated_longitude] end def coordinates_text \"lat: #{aggregated_latitude}, long: #{aggregated_longitude}\" end DEFAULT_AGGR_LAT = 0.5 def aggregated_latitude if lat \u003e 123 (lat + 0.123) / 3 elsif lat \u003c 0.23 (lat + 24) * 1.5 else DEFAULT_AGGR_LAT end end DEFAULT_AGGR_LONG = 0.5 def aggregated_longitude if long \u003e 4 (long - 0.25) * 2.3 elsif long \u003c -3 long.abs / 1.1 else DEFAULT_AGGR_LONG end end end As a result, we‚Äôve ended up with all of the functionality moved to the ‚Äúchild‚Äù class to address the ‚ÄúTell, Don‚Äôt Ask‚Äù. Of course, this is not always like this.\nPlease, keep in mind, that this is a pretty simple and totally made-up example.\nThe real-life production code frequently has loops, map, each, etc., collections-related usage, which brings its own additional questions.\nBut overall, the main principle remains the same.\nExtract everything into smaller methods that are simpler to test, read, and reason about.\n","tags":["ruby","rubyonrails","refactoring"],"title":"Prefer simple methods","uri":"/posts/prefer-short-methods/"},{"categories":["Ruby","Ruby on Rails"],"content":"# RuntimeError \u003c StandardError \u003c Exception \u003c Object begin require 'does/not/exist' rescue Exception =\u003e e \"it is an Exception\" end # =\u003e \"it is an Exception\" begin require 'does/not/exist' rescue StandardError =\u003e e \"it is an Exception\" end # =\u003e LoadError: cannot load such file -- does/not/exist What is the difference in results between this\nraise \"Oups\" rescue \"Hi\" and this?\nrequire 'does/not/exist' rescue \"Hi\" And why the results are different. Let‚Äôs figure it out step by step.\nIt turns out that a rescue clause without an explicit Exception class will rescue all StandardErrors (and inherited ones).\nI.e., if we just raise with some string, the plain rescue will catch it\ndef foo raise \"Oups\" end foo rescue \"Hello\" #=\u003e \"Hello\" because the raise \"some string\" raises RuntimeError which inherits from StandardError.\nBut if we raise an Exception, it won‚Äôt catch it, and we will have it raised.\ndef foo raise Exception end foo rescue \"Hello\" #=\u003e Exception: Exception Here is another good example from Ruby‚Äôs documentation:\nrequire 'does/not/exist' rescue \"Hi\" # =\u003e LoadError The rescue does not catch it because the LoadError is inherited from Exception (via ScriptError), not from StandardError.\nLoadError \u003c ScriptError \u003c Exception If you need to rescue any error type/exception, it can be done like this:\nbegin # any error type/exception rescue Exception =\u003e e \"I will catch all of you\" end Let‚Äôs check this out by raising different types explicitly.\nE.g., a descendant of Exception like LoadError \u003c ScriptError \u003c Exception:\nbegin raise LoadError rescue Exception =\u003e e \"caught\" end # =\u003e \"caught\" E.g., a descendant of StandardError like FiberError \u003c StandardError:\nbegin raise FiberError rescue Exception =\u003e e \"caught\" end # =\u003e \"caught\" E.g., a descendant of RuntimeError like FrozenError \u003c RuntimeError \u003c StandardError:\nbegin raise FrozenError rescue Exception =\u003e e \"caught\" end # =\u003e \"caught\" And just plain raise:\nbegin raise \"some explanation\" rescue Exception =\u003e e \"caught\" end # =\u003e \"caught\" As you can see, no matter what type is raised, it is always caught with rescue Exception.\nHere is a shortcut to remember:\nStandardError ‚Äì default for rescue RuntimeError ‚Äì default for raise Exception - is a parent of all of them Let your exceptions be all caught and and properly handled üëç\n","tags":["ruby","rubyonrails","development"],"title":"Exception vs StandardError","uri":"/posts/exception-vs-standard-error/"},{"categories":["Data structures","Tutorial"],"content":"a = Stack() # [] a.push('one') # ['one'] a.push('two') # ['one', 'two'] a.top() # 'two' a.push('three') # ['one', 'two', 'three'] a.top() # 'three' a.size() # 3 a.pop() # 'three' ['one', 'two'] a.pop() # 'two' ['one'] This is the API I want to have for the ‚ÄòStack‚Äô data structure.\nLet‚Äôs implement it in Python step by step.\nThe official documentation recommends using ‚Äôlist‚Äô when you need ‚ÄòStack‚Äô.\nI prefer to have a dedicated class with all the treats under the hood instead of just list and its append instead of push.\nSo let‚Äôs define the class\nclass Stack: __list = [] An alternative way of defining and instantiating the instance variable would be with constructor like this\nclass Stack: def __init__(self): self.__list = [] But at this point, this looks like overkill, so let‚Äôs stick to the first variant.\nTwo _ in the __list name are there to make it kind of ‚Äúprivate‚Äù and prevent accessing it directly like this\na = Stack() a.__list # AttributeError: 'Stack' object has no attribute '__list' First things first, I want this class to be a bit more user-friendly. Currently, it looks like this\nStack() # \u003c__main__.Stack object at 0x10df87fd0\u003e which is not helpful of course.\nIn Python this is done with the help of __str__() method that should return string. It would be logical to show the string representation of the __list content.\nFor this to happen there is str() builtin function which is just the instantiation of the str class. Isn‚Äôt that clever?\nHere is what it looks like\nclass Stack: __list = [] def __str__(self): return str(self.__list) That‚Äôs it.\nNow it behaves a bit more user friendly\na = Stack() print(a) # [] But without print, it is still cryptic\nStack() # \u003c__main__.Stack object at 0x10df87fd0\u003e For this to ‚Äúfix‚Äù there is __repr__()\n# \u003cskipped\u003e def __repr__(self): return str(self) Let‚Äôs check it out\nStack() # [] Yay! üéâ\nNext, let‚Äôs implement the stack‚Äôs push method.\nclass Stack: # \u003cskipped\u003e def push(self, el): return self.__list.append(el) Yep. Our stack grows to the right and ‚Äúpops‚Äù back to the left. The appending and removing values from the end of the list are O(1) operations in Python.\nCheck\na = Stack() # [] a.push('one') a # ['one'] Now to the pop.\nLuckily, the list already has the pop method that removes and returns the last item in the list; exactly what we need.\nclass Stack: # \u003cskipped\u003e def pop(self): return self.__list.pop() Check\na = Stack() # [] a.push('one') # ['one'] a.push('two') # ['one', 'two'] a.pop() # 'two' a # ['one'] a.pop() # 'one' a # [] So far so good. There are two top and size methods left.\nThe size is the same as len() builtin function and the top is just a reading of the first element.\nclass Stack: # \u003cskipped\u003e def size(self): return len(self.__list) def top(self): return self.__list[0] But here is a catch. If the list is empty, the top will raise the IndexError error\na = Stack() a.top() # IndexError: list index out of range So we need some kind of a fallback to None value. This is the null in Python.\nHere is the adjusted version of the top method\nclass Stack: # \u003cskipped\u003e def top(self): return None if self.size() == 0 else self.__list[0] It looks like we have everything in place. Here is the full code of the Stack class\nclass Stack: __list = [] def push(self, el): self.__list.append(el) return self def pop(self): return self.__list.pop() def size(self): return len(self.__list) def top(self): return None if self.size() == 0 else self.__list[0] def __str__(self): return str(self.__list) def __repr__(self): return str(self) And it works as expected\na = Stack() # [] a.push('one') # ['one'] a.push('two') # ['one', 'two'] a.top() # 'two' a.push('three') # ['one', 'two', 'three'] a.top() # 'three' a.size() # 3 a.pop() # 'three' ['one', 'two'] a.pop() # 'two' ['one'] Let‚Äôs add the cherry üçí on the top üòä. Let‚Äôs allow for initial values.\nTo make it happen we need a constructor method, which is __init__() in Python.\nclass Stack: # __list = [] \u003c= delete this line def __init__(self, initial=[]): self.__list = list(initial) The initial=[] is the nice ‚Äútrick‚Äù to provide a default value, so we still can initialize it empty a = Stack().\nBut when we need to provide an initial collection of values, we could do it as Stack([1,2,3]).\nAlso, the use of the list() class instantiator allows for any collection-like type to be used. E.g.\na = Stack( [1,2,3] ) a = Stack( (1,2,3) ) At this point, we have a pretty ‚Äúfull-fledged‚Äù Stack class at our disposal üéâ\nI am using this not so complex example on purpose.\nThis way it is easier to learn bit by bit the different idioms along the way, and at the same time not being bored and overwhelmed by a complex problem at hand.\n","tags":["python"],"title":"Let‚Äôs implement ‚ÄòStack‚Äô in Python","uri":"/posts/stack-in-python/"},{"categories":["Ruby"],"content":"\nIn the previous JavaScript like object in Ruby on Rails article, I‚Äôve described how similar behavior can be achieved in Rails code.\nBut in pure Ruby there still is no short way for this.\nIt turns out that a proposal to Ruby core has been made to add this nice-to-have feature.\nThe idea is simple and elegant at the same time.\nWhat if we add some ‚Äúsugar‚Äù that runs the following code under the hood\nperson = Struct.new(:name, :country).new('Yukihiro', 'Japan') # =\u003e #\u003cstruct name=\"Yukihiro\", country=\"Japan\"\u003e puts person.name # =\u003e \"Yukihiro\" And this is exactly what Koichi Sasada proposes in his PR.\nThe ‚Äúsugar‚Äù syntax would be like this for the above example\nperson = ${name: 'Yukihiro', country: 'Japan'} // =\u003e #\u003cstruct name=\"Yukihiro\", country=\"Japan\"\u003e puts person.name // =\u003e \"Yukihiro\" It makes it not only easier to write the .name instead of the additional three characters [:], but also helps when you make a typo like person.nama.\nYou‚Äôll get an error raised\n\u003e person.nama NoMethodError: undefined method `nama' for #\u003cstruct name=\"Yukihiro\", country=\"Japan\"\u003e Did you mean? name instead of the silent nil with the Hash type\nperson = {name: 'Yukihiro'} person[:nama] # =\u003e nil Let‚Äôs hope that this change will make it one way or another into the Ruby core üëç\n","tags":["ruby","development"],"title":"JavaScript-like HashMaps in Ruby","uri":"/posts/js-like-hashmap-in-ruby/"},{"categories":["PostgreSQL","SQL"],"content":"\nToday I‚Äôve learned about one of the useful PostgreSQL features - ‚Äòunlogged‚Äô tables.\nWhat does this feature exist for?\nSay you need to cache some transient data and you don‚Äôt really care about it being persisted after a server crash, enter ‚Äòunlogged‚Äô tables.\nIf you need to ‚Äúspeed-up‚Äù your existing table this unsafe way, you can do it like this\nalter table \"your_table_name\" set unlogged; But to what extent is it ‚Äúunsafe‚Äù?\nThe types and all of the data are the same; the indexes and like that including. They are not the same as temporary tables.\nSo you don‚Äôt need to change any of your code that uses such tables.\nIt just works (R) üéâ\nThen what is the ‚Äúcatch‚Äù for this ‚Äúspeed it up for free‚Äù?\nOf course, there is nothing for free üòÉ. By switching a table to ‚Äòunlogged‚Äô you‚Äôre excluding this table from the ‚Äúlogging‚Äù daemon‚Äôs list.\nThe so-called WAL - Write-Ahead Logging is the nice ‚Äúworkhorse‚Äù that makes sure your data is correct and persistent in case of any server failure or abnormal exit.\nAlso, by switching your table to ‚Äòunlogged‚Äô you are effectively ‚Äúdisabling‚Äù the copying of writes to this table to other servers.\nAnd that‚Äôs basically it, folks (R) üòÉ\nIn case you‚Äôve changed your mind and need to switch back to ‚Äúsafe‚Äù, it‚Äôs easy as well, just\nalter table \"your_table_name\" set logged; Here is a handy query for you: ‚Äúshow me all of the ‚Äòunlogged‚Äô tables, foreign keys, and indexes‚Äù:\nselect relname from pg_class where relpersistence = 'u'; Of course, there are much more use cases for this ‚Äòunlogged‚Äô feature, so I encourage you to go ‚Äúgoogle‚Äù them in case ‚Äúyou‚Äôve been sold‚Äù on it üòÉüëç\n","tags":["postgresql","development"],"title":"What is ‚Äòunlogged‚Äô in PostgreSQL for","uri":"/posts/what-is-unlogged-in-postgresql-for/"},{"categories":["Ruby on Rails","Useful Tricks"],"content":"\nOne day, when I was explaining how the routing \u003e params \u003e controllers \u003e views work, I wanted to keep things as simple as possible, so I needed a way to flexibly ‚Äúmock‚Äù AR objects.\nAnd the JavaScript-like objects would be a good-enough solution for it.\nlet obj = {} obj.some_field // undefined - N.B. no error raised obj.some_field = \"some value\" obj.some_field // \"some value\" - JS \"magic\" In contrast, the Ruby‚Äôs Object does not allow it.\nThe nearest Ruby‚Äôs type to flexibly fake a model is Hash.\nBut you need to use those [...] square brackets with key names\nobj = {} obj[:some_field] # nil obj[:some_field] = \"some value\" obj[:some_field] # \"some value\" which breaks the controller and views code that expects it to be like this\n\u003c%= user.name %\u003e # and not \u003c%= user[:name] %\u003e It turns out that the Ruby on Rails already has this JS-like functionality.\nEnter the ActiveSupport::OrderedOptions \u003c Hash\nobj = ActiveSupport::OrderedOptions.new obj.some_field # nil obj.some_field = \"some value\" obj.some_field # \"some value\" And it has a ‚Äúbonus‚Äù. If you need it to raise an exception when the value is blank, just add a bang !\nobj.some_empty_field! # =\u003e raises KeyError: :some_empty_field is blank Also, it has a useful ‚Äúsibling‚Äù ActiveSupport::InheritableOptions which allows to initialize from other such objects or Hash-es.\nobj = ActiveSupport::InheritableOptions.new({ some_field: \"some value\" }) obj.some_field # \"some value\" obj.some_empty_field # nil Yay üéâ\nDisclaimer: I know that it is best to fake the AR models by introducing step by step all of the parts of the ActiveModel into a PORO. But for a person that‚Äôs new to the Rails it would be an unnecessary mental (over)loading at this stage. And the person already new the JavaScript üòÖ so the choice was obvious.\n","tags":["rubyonrails","development"],"title":"JavaScript like object in Ruby on Rails","uri":"/posts/js-like-object-in-rails/"},{"categories":["Ruby on Rails","Useful Tricks"],"content":"\nI was explaining what the rails db:migrate command does under the hood and I wanted to demonstrate what SQL queries the Rails generates.\nAnd it would be nice for them to be colorful of course üòÉ\nThe ‚Äúcolorful‚Äù part can be done by adding the gem pry-rails\n@@ -38,6 +38,7 @@ gem 'bootsnap', '\u003e= 1.1.0', require: false group :development, :test do # Call 'byebug' anywhere in the code to stop execution and get a debugger console gem 'byebug', platforms: [:mri, :mingw, :x64_mingw] + gem 'pry-rails' end Do not forget about the running of the bundle install command to actually get it installed.\nAnd the ‚Äúunder the hood‚Äù part can be done in a common way by adding the log rake task.\nCreate the log.rake file in the lib/tasks folder and add the following to it\ntask :log =\u003e :environment do ActiveRecord::Base.logger = Logger.new(STDOUT) end That‚Äôs it. Now you can see what happens under the hood for any of the rake tasks üéâ\nJust prefix any of your rake tasks with the log like this\nrails log db:migrate D, [2020-05-26T17:21:01.768098 #34442] DEBUG -- : (0.2ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC I, [2020-05-26T17:21:01.768242 #34442] INFO -- : Migrating to CreateUser (20200526154925) D, [2020-05-26T17:21:01.769307 #34442] DEBUG -- : (0.0ms) begin transaction == 20200526154925 CreateUser: migrating ======================================= -- create_table(:users) D, [2020-05-26T17:21:01.770206 #34442] DEBUG -- : (0.5ms) SELECT sqlite_version(*) D, [2020-05-26T17:21:01.770964 #34442] DEBUG -- : (0.6ms) CREATE TABLE \"users\" (\"id\" integer PRIMARY KEY AUTOINCREMENT NOT NULL, \"name\" varchar) -\u003e 0.0016s == 20200526154925 CreateUser: migrated (0.0017s) ============================== D, [2020-05-26T17:21:01.773149 #34442] DEBUG -- : ActiveRecord::SchemaMigration Create (0.6ms) INSERT INTO \"schema_migrations\" (\"version\") VALUES (?) [[\"version\", \"20200526154925\"]] D, [2020-05-26T17:21:01.773894 #34442] DEBUG -- : (0.6ms) commit transaction D, [2020-05-26T17:21:01.775636 #34442] DEBUG -- : ActiveRecord::InternalMetadata Load (0.4ms) SELECT \"ar_internal_metadata\".* FROM \"ar_internal_metadata\" WHERE \"ar_internal_metadata\".\"key\" = ? LIMIT ? [[\"key\", \"environment\"], [\"LIMIT\", 1]] D, [2020-05-26T17:21:01.778797 #34442] DEBUG -- : (0.0ms) begin transaction D, [2020-05-26T17:21:01.779282 #34442] DEBUG -- : (0.0ms) commit transaction D, [2020-05-26T17:21:01.780075 #34442] DEBUG -- : (0.1ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC And here is the ‚Äúbonus‚Äù part üòÉ\nrails log db:rollback D, [2020-05-26T17:23:08.987414 #34600] DEBUG -- : (0.1ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC D, [2020-05-26T17:23:08.987785 #34600] DEBUG -- : (0.0ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC D, [2020-05-26T17:23:08.988073 #34600] DEBUG -- : (0.0ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC D, [2020-05-26T17:23:08.988628 #34600] DEBUG -- : (0.0ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC I, [2020-05-26T17:23:08.988677 #34600] INFO -- : Migrating to CreateUser (20200526154925) D, [2020-05-26T17:23:08.991078 #34600] DEBUG -- : (0.0ms) begin transaction == 20200526154925 CreateUser: reverting ======================================= -- drop_table(:users) D, [2020-05-26T17:23:08.994696 #34600] DEBUG -- : (1.3ms) DROP TABLE \"users\" -\u003e 0.0015s == 20200526154925 CreateUser: reverted (0.0035s) ============================== D, [2020-05-26T17:23:08.995986 #34600] DEBUG -- : ActiveRecord::SchemaMigration Destroy (0.4ms) DELETE FROM \"schema_migrations\" WHERE \"schema_migrations\".\"version\" = ? [[\"version\", \"20200526154925\"]] D, [2020-05-26T17:23:08.996694 #34600] DEBUG -- : (0.6ms) commit transaction D, [2020-05-26T17:23:08.997293 #34600] DEBUG -- : (0.1ms) SELECT \"schema_migrations\".\"version\" FROM \"schema_migrations\" ORDER BY \"schema_migrations\".\"version\" ASC All kudos go to Josh https://stackoverflow.com/a/8335695/3874570 üëç\n","tags":["rubyonrails","development"],"title":"Show me SQL generated by rake tasks","uri":"/posts/show-me-sql-generated-by-rake-tasks/"},{"categories":["AI","Machine learning"],"content":"\nThis a bit of pretentious title is about the setup of the great PySC2 library which makes it possible to ‚Äúrule‚Äù the StarCraft II with your own AI.\n‚ÄúScientifically‚Äù speaking, the PySC2 allows for Reinforcement Learning agents to interact with the StarCraft II game. The library does it by exposing the StarCraft II Machine Learning API as a Python RL Environment.\nYou can learn more about the Reinforcement Learning by reading A Beginner‚Äôs Guide to Deep Reinforcement Learning article. And also, here Wikipedia\nThe below are described the steps necessary to set up the working environment for it, so let‚Äôs make it happen.\nThe Homebrew is the preferred way to install packages for macOS, so make sure that it is installed.\nIn case it is not, here are the necessary steps.\nFirst, install the Command Line Tools for Xcode\nxcode-select --install Then accept the XCode license\nsudo xcodebuild -license accept Now we are ready to install the Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" Let‚Äôs make the installed brew command of the Homebrew project available in your terminal console. Add the following line\nexport PATH=/usr/local/bin:$PATH to your preferred shell‚Äôs profile. E.g. it could be .bash_profile, or .zshrc.\nIf you are unsure you can take the ‚Äúcompromise‚Äù way and use the .profile.\nIf you have no preferred text editor, you can use nano\nnano ~/.profile Insert that line export PATH=/usr/local/bin:$PATH into the nano, then press Ctrl + o, then enter, and finally Ctrl + x.\nNow type\nsource ~/.profile (or whatever your preferred shell‚Äôs profile) for the added line to take effect, and then\nbrew update This way we update the brew package manager‚Äôs database.\nAnd here goes the tricky part.\nAt the moment of writing this article, the TensorFlow does not support yet Python 3.7 that is being installed by default with the Homebrew. We need to install the Python 3.6 for things to go smoothly later.\nLuckily there is a simple way for it.\nWe will use the python: update 3.6.5_1 bottle commit.\nIn case, you already have installed the Python 3.7 unlink it first\nbrew unlink python Note: this command won‚Äôt remove the 3.7 version from your system.\nThen install the Python 3.6\nbrew install --ignore-dependencies https://raw.githubusercontent.com/Homebrew/homebrew-core/f2a764ef944b1080be64bd88dca9a1d80130c558/Formula/python.rb Now check that we have the right version\npython3 -V It should be Python 3.6.5.\nCongratulations üéâ.\nThe next step is not necessary but recommended.\nIt is useful for cases when you screw something up and would like to go ‚Äúfrom the scratch‚Äù.\nLet‚Äôs install and use the virtualenv\nmkdir ~/.virtualenvs pip3 install virtualenv virtualenvwrapper And to make it available in your terminal console, add these lines to your shell‚Äôs profile\n# virtualenv and virtualenvwrapper export WORKON_HOME=$HOME/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3 source /usr/local/bin/virtualenvwrapper.sh and then load it for those lines to take effect\nsource ~/.profile (or whatever your shell‚Äôs preferred profile is).\nPay attention to the terminal output so there are no errors.\nNow we are ready to create a dedicated virtual environment which we‚Äôll use for our further setup.\nLet‚Äôs call it sc2.\nmkvirtualenv sc2 -p python3 After this command, your prompt should be prefixed with (sc2).\nIf you would like to switch to this virtual environment in another terminal tab, or get back to it after you‚Äôve closed your previous one, just type\nworkon sc2 Now we finally are ready to install the PySC2.\npip install pysc2 Now go to the https://www.blizzard.com and get the StarCraft II installed. The starter edition will suffice for our experiments.\nFor the PySC2 library to work we need to download and extract some additional materials.\nThe Ladder maps and Mini-games.\nThey go to the StarcraftII/Maps/ directory.\nThis folder does not exist by default so we should create it first.\ncd ‚Äú/Applications/StarCraft II‚Äù mkdir Maps open Maps Now download those archives and extract them into the newly created Maps folder.\nThe map packs are licensed.\nFollow the instructions here https://github.com/Blizzard/s2client-proto.\nBasically, you just need to enter the iagreetotheeula in the password field while extracting those. By typing this in you agree to be bound by the terms of the AI and Machine Learning License. That‚Äôs it.\nNow, after you‚Äôve installed the StarCraft II game client and downloaded all the additional materials, you can start experimenting\nhttps://github.com/deepmind/pysc2#run-an-agent\nRun this command to check out that everything works fine\npython -m pysc2.bin.agent -map Simple64 If you‚Äôve got the StarCraft II opened in a mini window with PySC2 doing it‚Äôs RL job, then congratulations! ‚ú®üéâ\n","tags":["ai","machine-learning","setup","tensor-flow","python"],"title":"Unleash your AI to rule the StarCraft2 (on macOS)","uri":"/posts/unleash-your-ai-to-rule-the-sc2-on-macos/"},{"categories":["Ruby on Rails","Useful Tricks"],"content":"\nIf we run rails new -h we see that we can disable generating of some parts of a new rails project.\nIn this article I am going to dissect these particular options:\n-S, [--skip-sprockets] # Skip Sprockets files -J, [--skip-javascript] # Skip JavaScript files [--skip-turbolinks] # Skip turbolinks gem -O, [--skip-active-record] # Skip Active Record files Starting point I am going to use the GitHub pull requests to see the differences in each case.\nSo I have run the rails new simplest4 -O -S -J --skip-turbolinks and pushed it into the master branch.\nThe result is here: https://github.com/alexkval/simplest4\nIt‚Äôs a pretty empty Rails project without Sprockets, JavaScript, ActiveRecord, and Turbolinks for now.\nBringing JavaScript in By running the same rails new command, but without -J, I am adding the JavaScript part.\nThe result can be seen in this pull request: Without -J (+ JavaScript)\nSo what we have in it.\nThese lines have been added to the Gemfile:\n# Use CoffeeScript for .coffee assets and views gem 'coffee-rails', '~\u003e 4.1.0' # See https://github.com/rails/execjs#readme for more supported runtimes # gem 'therubyracer', platforms: :ruby # Use jquery as the JavaScript library gem 'jquery-rails' The jquery-rail gem brings in the jQuery library and the jquery-ujs gem, which is ‚ÄúRuby on Rails unobtrusive scripting adapter for jQuery‚Äù.\nHere is the diff of the app/views/layouts/application.html.erb:\n@@ -3,6 +3,7 @@ \u003chead\u003e \u003ctitle\u003eSimplest4\u003c/title\u003e \u003c%= stylesheet_link_tag 'application', media: 'all' %\u003e + \u003c%= javascript_include_tag 'application' %\u003e \u003c%= csrf_meta_tags %\u003e \u003c/head\u003e \u003cbody\u003e And the diff of the app/assets/javascripts/application.js is:\n+// \u003c... skipped comments ...\u003e +//= require jquery +//= require jquery_ujs +//= require_tree . That‚Äôs all for the JavaScript part of the generator.\nSprockets This time I am running the rails new command without -S. It adds back the Sprockets part.\nThe result can be seen in this pull request: Without -S (+ Sprockets)\nLet‚Äôs take a look into it.\nThe following lines have been added to the Gemfile:\n# Use SCSS for stylesheets gem 'sass-rails', '~\u003e 5.0' # Use Uglifier as compressor for JavaScript assets gem 'uglifier', '\u003e= 1.3.0' The diff of the config/application.rb is:\n@@ -8,7 +8,7 @@ require \"action_controller/railtie\" require \"action_mailer/railtie\" require \"action_view/railtie\" -# require \"sprockets/railtie\" +require \"sprockets/railtie\" require \"rails/test_unit/railtie\" And this has been added to the config/environments/development.rb:\n# Debug mode disables concatenation and preprocessing of assets. # This option may cause significant delays in view rendering with a large # number of complex assets. config.assets.debug = true # Asset digests allow you to set far-future HTTP expiration dates on all assets, # yet still be able to expire them through the digest params. config.assets.digest = true # Adds additional error checking when serving assets at runtime. # Checks for improperly declared sprockets dependencies. # Raises helpful error messages. config.assets.raise_runtime_errors = true This goes to the config/environments/production.rb:\n# Compress JavaScripts and CSS. config.assets.js_compressor = :uglifier # config.assets.css_compressor = :sass # Do not fallback to assets pipeline if a precompiled asset is missed. config.assets.compile = false # Asset digests allow you to set far-future HTTP expiration dates on all assets, # yet still be able to expire them through the digest params. config.assets.digest = true # `config.assets.precompile` and `config.assets.version` have moved to config/initializers/assets.rb And these lines go to the config/initializers/assets.rb:\n# Be sure to restart your server when you modify this file. # Version of your assets, change this if you want to expire all your assets. Rails.application.config.assets.version = '1.0' # Add additional assets to the asset load path # Rails.application.config.assets.paths \u003c\u003c Emoji.images_path # Precompile additional assets. # application.js, application.css, and all non-JS/CSS in app/assets folder are already added. # Rails.application.config.assets.precompile = %w( search.js ) Everything is well described in the comments.\nTurbolinks By just removing the --skip-turbolinks flag and without bringing back the JavaScript it won‚Äôt yield anything related to the Turbolinks.\nThe generated code is the same as with the Sprockets flag.\nThis means that you obviously need both the JavaScript and Sprockets for the Turbolinks.\nHere is the resulted PR.\nHere are the changes related to the Turbolinks only:\nGemfile\n# Turbolinks makes following links in your web application faster. Read more: https://github.com/rails/turbolinks gem 'turbolinks' app/assets/javascripts/application.js\n//= require jquery //= require jquery_ujs +//= require turbolinks //= require_tree . application.html.erb\n@@ -2,7 +2,8 @@ \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eSimplest4\u003c/title\u003e - \u003c%= stylesheet_link_tag 'application', media: 'all' %\u003e + \u003c%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' =\u003e true %\u003e + \u003c%= javascript_include_tag 'application', 'data-turbolinks-track' =\u003e true %\u003e \u003c%= csrf_meta_tags %\u003e \u003c/head\u003e \u003cbody\u003e And that‚Äôs it for the Turbolinks part.\nActiveRecord The resulted pull request is here.\nGemfile\n# Use sqlite3 as the database for Active Record gem 'sqlite3' config/application.rb\nrequire \"active_job/railtie\" -# require \"active_record/railtie\" +require \"active_record/railtie\" require \"action_controller/railtie\" module Simplest4 class Application \u003c Rails::Application + # Do not swallow errors in after_commit/after_rollback callbacks. + config.active_record.raise_in_transactional_callbacks = true end end The config/database.yml file has been added as well. It is pre-filled with default settings for the SQLite database.\nThe warnings about the pending migrations have been enabled in the config/environments/development.rb:\n# Raise an error on page load if there are pending migrations. config.active_record.migration_error = :page_load The dumping of the schema is disabled for production in the config/environments/production.rb:\n# Do not dump schema after migrations. config.active_record.dump_schema_after_migration = false And the fixtures are enabled in the test/test_helper.rb:\nrequire 'rails/test_help' class ActiveSupport::TestCase # Setup all fixtures in test/fixtures/*.yml for all tests in alphabetical order. fixtures :all end An outcome Here I‚Äôve demonstrated one of the tricks I use for the learning of new tools.\nDoing it ‚Äústep-by-step‚Äù gives a much deeper understanding of how things work.\n","tags":["rubyonrails","development"],"title":"Dissecting of the ‚Äòrails new‚Äô command","uri":"/posts/dissecting-rails-new/"}]
